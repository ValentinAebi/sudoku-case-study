
package Main {

    main fn solver_main(args: arr String){

        // Parse arguments
        val filename: String;
        if args[0] == "1" {
            filename = "./grids/grid1.txt";
        } else if args[0] == "2" {
            filename = "./grids/grid2.txt";
        } else {
            panic "unrecognized argument";
        };

        // use IntTableReader library to read the sudoku grid in the file
        val rawCharsGrid: arr^# arr^# Char;
        enclosed {fs} {
            rawCharsGrid = IntTableReader.readTable(filename);
        };

        // copy the table produced by the unchecked library into a table that we fully control
        val cgr = newreg;
        val charsGrid: arr^{cgr} arr^{cgr} Char;
        enclosed {} {
            charsGrid = sanitizeTable(rawCharsGrid, cgr);
        };

        assert(len charsGrid == gridDim, "wrong grid height");
        assert(len charsGrid[0] == gridDim, "wrong grid width");

        // Create the grid and display its state before solving
        val frameR = newreg;
        val valuesR = newreg;
        val grid = GridMaker.mkGrid(frameR, valuesR, cgr, charsGrid);
        printFormatted(grid);
        console.print("\n" + grid.missingCnt() as String + " empty cells\n\n\n");

        // Perform resolution. The Solver module is not allowed to use devices.
        val result: ResolutionResult;
        restricted {frameR, valuesR} {
            result = Solver.solve(grid);
        };
        if result is ResolutionSuccess {
            console.print("Resolution succeeded with " + result.maxBacktrackDepth as String + " guessed step(s)\n");
        } else {
            console.print("Resolution failed\n");
        };

        // Display the grid once it has been solved (or at least once the solver inferred all the values that it could)
        printFormatted(grid);
        console.print("\n" + grid.missingCnt() as String + " empty cells");
    }

    private fn printFormatted(grid: Grid^){
        val tableR = newreg;
        val charsTable = grid.toCharsTable(tableR);
        enclosed {console} {
            val tableCopy = #(arr@newreg arr^# Char[len charsTable]);
            for var i = 0; i < len tableCopy; i += 1 {
                tableCopy[i] = #charsTable[i];
            };
            (new GridFormatter(sectorDim, sectorDim)).format(tableCopy);
        };
    }

    private fn sanitizeTable(rawTable: arr^# arr^# Char, r: Region^) -> arr^{r} arr^{r} Char {
        val res: arr^{r} arr^{r} Char;
        enclosed {r} {
            res = arr@r arr^{r} Char[len rawTable];
            for var i = 0; i < len rawTable; i += 1 {
                val rawRow = rawTable[i];
                res[i] = arr@r Char[len rawRow];
                for var j = 0; j < len rawRow; j += 1 {
                    res[i][j] = rawRow[j];
                }
            };
        };
        return res;
    }

    fn assert(cond: Bool, msg: String){
        if !cond {
            panic msg
        }
    }

}
